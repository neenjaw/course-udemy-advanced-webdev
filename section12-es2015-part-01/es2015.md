# ES2015 - Part 1

## Objectives

- Understand what ES2015 is and how the term arose.
- Refactor code to use let and const and explain the differences and implications
- use template strings
- use arrow functions
- use object enhancements
- explain and use default parameters
- using rest and spread making use of destructuring

### Less used ES2015 features

- [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)
- [Symbols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)

## let / const / var

### const

Primitives are immutable, by objects (things passed by reference) are mutable.  But you cannot declare these again.  These have 'block scoping'.

### let

Allows mutable primitives, difference from var is that let is 'block scoped' not 'function scoping' like var.  Also, let is hoisted like var is, but a 'temporal dead zone' is used to restrict the value of it until it is encountered in the code.

## template strings

```js

let x = `this is a template string ${variable} ${canAlsoCallFunction()}`;

let y = `You
can
even
do
multiline
strings`;

```

## arrow functions

```js
// instead of this:
var fxnA = function (v) {

};

// can write:
var fxnB = (v) => {};

//----------------------------

// ES5
[1,2,3].map(function(value) {
    return value * 2;
});

//ES2015
[1,2,3].map(value => value * 2);

//----------------------------

//ES5
function doubleAndFilter(arr) {
    return arr.map(function(v) {
        return v * 2;
    })
    .filter(function(v) {
        return v % 3 ===0;
    });
}

//ES2015
var doubleAndFilter = arr => arr
    .map(val => val * 2)
    .filter(num => num % 3 === 0);
```

### differences

- arrow functions do not set the context of `this`

```js
//problem
var instructor = {
    firstName = 'Elie',
    sayHi = function () {
        setTimeout(function() {
            console.log('Hello ' + this.firstName); // undefined
        }, 1000);
    }
}

//es5 solution - using bind()
var instructor = {
    firstName = 'Elie',
    sayHi = function () {
        setTimeout(function() {
            console.log('Hello ' + this.firstName); // ELie
        }.bind(this), 1000);
    }
}

//es6 solution - using the arrow function
var instructor = {
    firstName = 'Elie',
    sayHi = function () { // <-- can't put an arrow function here because we WANT to set the context of `this`
        setTimeout(() => {
            console.log('Hello ' + this.firstName); // Elie
        }, 1000);
    }
}
```

### Warning

We should **never** use arrow functions as methods in objects, since it just won't work.

## 